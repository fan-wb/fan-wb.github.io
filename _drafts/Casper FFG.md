---

title: 以太坊 PoS 共识协议详解（二）：Casper FFG

date: 2023-05-09 12:00:00 +0800

categories: [Consensus]

tags: [ethereum,pos]

math: true

image: https://fanwb.oss-cn-beijing.aliyuncs.com/img/casper.jpg
---

本文是介绍以太坊 PoS 共识协议的第二部分，主要对最终性模块 Casper FFG 进行全面说明。

有许多文章都介绍过 Casper FFG 的运作机制，但却很少说明该机制为什么有效。希望本文能为理解 Casper FFG 的有效性提供一些参考。

总体而言，Casper FFG 的机制并不复杂，其有效性主要归功于为两个重要理念：**两阶段提交**，以及**可问责安全性**。

两阶段提交赋予了 Casper FFG 经典的共识安全性，令其能够声明区块是最终化的，并确信诚实验证者永远不会回滚最终化的区块。但两阶段提交生效的条件是诚实验证者控制至少三分之二的质押权益。因此，针对作恶验证者超过三分之一的情况，Casper FFG 还提供了可问责安全性作为额外的保障。如果链上出现最终性冲突，至少三分之一的总质押权益会经由罚没作恶验证者被销毁。

## 概述

Casper FFG 是一种元共识协议。可以作为覆盖层运行在底层共识协议之上，为其添加最终性。回顾一下，最终性是保证链中的一些区块永远不会被回滚的属性。在以太坊的权益证明共识中，底层协议 LMD GHOST 并不提供最终性，验证者构建竞争链不会受到惩罚。Casper FFG 的作用就是作为“最终性小工具 (finality gadget) ”来为 LMD GHOST 添加最终性。

Casper FFG 利用了权益证明协议的性质：参与者是已知的（管理质押以太坊的验证者）。因此，可以通过计数来判断是否获得多数诚实验证者的投票（确切地说是管理多数质押权益的验证者的投票，每个验证者的投票都会根据其管理的权益价值被加权，简单起见，这一点后文不再赘述）。

协议在异步网络 (Internet) 上运行，这意味着如果想同时实现安全性和活性，最多只能容忍$\frac{1}{3}$的验证者存在恶意或故障。这是共识理论中的一个著名结论，推理如下：

- 设共有 $n$ 个验证者，其中 $f$ 个可能以某种方式存在故障或恶意。
- 为了保持活性，协议需要在只收到 $n-f$ 个验证者的响应后就能做出决定，因为那 $f$ 个验证者可能无法或拒绝进行投票。
- 但由于是异步环境，所以未收到的 $f$ 个响应可能只是延迟了，并非故障导致。
- 因此，必须考虑在收到的 $n-f$ 个响应中，最多可能有 $f$ 个来自有故障或恶意验证者。
- 为了保证在收到 $n-f$ 个验证者响应后诚实验证者的仍占多数，则需要 $\frac{(n-f)}{2} > f$，即 $f <\frac{n}{3}$。

总之，与所有经典拜占庭容错 (BFT) 协议一样，Casper FFG 在不到三分之一的验证者集存在故障或恶意时，能够提供最终性。而特别之处在于，即使超过三分之一的验证者存在故障或恶意行为，Casper FFG 仍能够提供经济最终性（可问责的安全性）。

本文将单独考虑 Casper FFG，不会过多花费时间讨论其如何与 LMD GHOST 集成。[Casper FFG 论文](https://arxiv.org/pdf/1710.09437.pdf)也几乎没有涉及到底层区块链共识机制。后续文章将继续探讨两者是如何结合为 Gasper 的。

## 命名

Casper FFG 协议的名称由两部分组成：

**Casper**

协议名中的 Casper 部分似乎出自 Vlad Zamfir 之手。正如他在《Casper 历史》[第五部分](https://medium.com/@Vlad_Zamfir/the-history-of-casper-chapter-5-8652959cef58)所解释的：

> 在本章中，我将讲述 Casper 协议的诞生，它是将 Aviv Zohar 和 Jonatan Sompolinsky 的 GHOST 协议应用于权益证明机制之上的产物。
> 我称之为“友好的幽灵”，因为其激励机制旨在对抗寡头垄断的审查制度：这些激励机制迫使卡特尔对非卡特尔验证者保持友好。

这里提到的 GHOST 协议就是在[前一篇文章](https://fan-wb.github.io/posts/011/)中介绍过的协议。Casper 这个名字其实来自 Casper the Friendly Ghost，是一个自 1940 年代以来就存在的卡通角色。

Zamfir 最初将协议命名为 Casper TFG（The Friendly Ghost，友好的幽灵），后来又改名为 Casper CBC（Correct By Construction，通过构建实现正确性）。Vitalik 的 Casper FFG 与 Zamfir 的 Casper TFG/CBC 几乎同时出现，但两者并没有什么共同之处，Casper FFG 也没有使用 GHOST 协议。

**FFG**

如 Casper FFG 论文标题所写，FFG 代表“Friendly Finality Gadget（友好的最终性小工具）”。这一命名在借鉴了 Zamfir 的 TFG 的同时，也表明了 Casper FFG 不是一个完全独立的区块链协议，而是一个可以添加到底层共识协议中实现最终性的“小工具”。

## 术语

### Epoch 和检查点

为了就最终性做出决定，Casper FFG 机制需要处理来自至少 $\frac{2}{3}$ 的验证者集的投票。在以太坊中，验证者集非常庞大，成千上万个验证者的投票同时广播、传播和处理是不现实的。

为了解决这个问题，投票会分散在 **Epoch** 的持续时间内进行，在 Eth2 中，一个 Epoch 由 32 个间隔 12 秒的 Slot 组成。在每个 Slot 中，总验证者集合的 $\frac{2}{3}$ 会被安排广播投票，因此每个验证者在每个 Epoch 会投票一次。实现中为了提高效率将每个验证者的 Casper FFG 投票与其 LMD GHOST 投票绑定在一起，但不是必须如此。

为了确保在不同时间投票的验证者拥有共同的投票对象，我们令其对**检查点** (Checkpoint) 进行投票，检查点是 Epoch 的第一个 **Slot**。第 $N$ 个 Epoch 的检查点位于第 $32N$ 个 Slot（Slot 和 Epoch 的编号从 0 开始）。

![](https://fanwb.oss-cn-beijing.aliyuncs.com/img/eth2book.info_capella_part2_consensus_casper_ffg_.png)
_一个 Epoch 分为 32 个 Slot，每个 Slot 通常包含一个区块 每个 Epoch 的第一个 Slot 是其检查点_

> “最终化 Epoch”这种表述是不正确的，Casper FFG 最终化的是检查点。当完成第 $N$ 个 Epoch 的检查点最终化时，也就最终化了含第 $32N$ 个 Slot 在内的所有内容，包括整个第 $N-1$ 个 Epoch 和第 $N$ 个 Epoch 的第一个 Slot。但第 $N$ 个 Epoch 并没有完成最终化，还有 31 个 Slot 未最终化。
{: .prompt-info }

暂且假设每个 Slot 都包含一个区块，因为原始的 Casper FFG 检查点是基于区块高度而不是 Slot 号的。在协议中，一个检查点对象只包含其 Epoch 编号以及 Epoch 第一个 Slot 中区块的哈希根 (root)：

```python
class Checkpoint(Container):
    epoch: Epoch
    root: Root
```

### 确认和最终化

与经典的 BFT 共识协议类似，Casper FFG 通过两轮流程（确认 "Justification"，最终化 "Finalization"）来实现最终性。

第一轮：我向网络广播对当前 Epoch 的检查点的看法（记为 $X$），并获取其他人的看法。如果绝大多数验证者也支持 $X$，那么我就可以对 $X$ 进行**确认**。确认仅限于我的网络视图：在这一阶段，我相信网络中的大多数验证者都认为 $X$ 对最终化有利。但是我还不知道网络上的其他人是否也得出了同样的结论。在对抗性条件下，可能有足够多的其他验证者无法就 $X$ 做出决定。

第二轮：我广播“我接收到的绝大多数验证者支持 $X$” 的消息（即，“我已经确认了 $X$”），并询问其他验证者是否认为绝大多数验证者支持 $X$（即，他们是否已经确认了 $X$）。如果绝大多数验证者同意 $X$ 是合理的，那么我将**最终化** $X$。最终化是全局属性：一旦一个检查点被最终化，任何诚实的验证者都不会将其回滚。即使其他验证者还没有在其视图中将该检查点标记为最终化，我也知道他们至少将其标记为了已确认，并且没有任何（不可惩罚的）行为能够撤销该确认。

总结一下，为了让我绝对确定整个网络都同意不会回滚某个区块，需要以下步骤：

1. 第一轮（理想情况下可确认）

   a. 我告诉网络我支持的检查点。

   b. 我从网络中获取其他验证者支持的检查点。

   c. 如果 $\frac{2}{3}$ 的验证者与我意见相同，我将确认该检查点。

2. 第二轮（理想情况下可最终化）

   a. 我将我已确认的检查点告诉网络。

   b. 我从网络中获取其他验证者已确认的检查点。

   c. 如果 $\frac{2}{3}$ 的验证者与我意见相同，我将最终化该检查点。

简而言之，当我确认一个检查点时，我承诺永远不回滚它。当我最终化一个检查点时，我知道所有诚实验证者都承诺永远不回滚它。

![](https://fanwb.oss-cn-beijing.aliyuncs.com/img/eth2book.info_capella_part2_consensus_casper_ffg_1.png)
_理想情况下，第一轮将确认检查点第二轮将最终化检查点_

在理想条件下，每轮持续一个 Epoch，因此确认检查点需要一个 Epoch，最终化检查点需要再花费一个 Epoch。

- 在 Epoch N 开始时，我们的目标是确认检查点$N-1$ 并最终化检查点$N-2$。
- 具体来说，协议中最终化一个检查点需要 12.8 分钟，即两个 Epoch。在 Casper FFG 中，这两轮是重叠流水线式的，因此尽管最终化一个检查点总共需要 12.8 分钟，但仍然可以做到每隔 6.4 分钟（即每个 Epoch）最终化一个检查点。
- 注意，在协议外部，如果不存在长链重组，则可以稍早于 12.8 分钟预见到某个检查点可能被最终化。例如可能在第二轮进行到 $\frac{2}{3}$ 的时候（大约 11 分钟）就收集了足够多的来自 $\frac{2}{3}$ 验证者的投票。但协议内部的确认和最终化仅在 Epoch 结束处理期间进行。

### 源和目标 链接和冲突

Casper FFG 中的投票包含两个部分：**源** (Source) 检查点投票和**目标** (Target) 检查点投票，即见证数据中的`source`和`target`字段：

```python
class AttestationData(Container):
    slot: Slot
    index: CommitteeIndex
    # LMD GHOST vote
    beacon_block_root: Root
    # FFG vote
    source: Checkpoint
    target: Checkpoint
```

源和目标投票同时以**链接** (Link) 的形式进行广播：$𝑠→𝑡$，其中 $s$ 是源检查点，$t$ 是目标检查点。

目标投票的作用是广播验证者视图中下一个应该被确认的检查点，是验证者的第一轮投票。目标投票对不会滚该检查点的软（条件性的）承诺，条件是收到 $\frac{2}{3}$ 的验证者对该检查点的承诺。

源投票的作用是广播验证者已经收到网络中 $\frac{2}{3}$ 的验证者支持检查点$s$，且 $s$ 是已知符合该条件的最新检查点，是验证者的第二轮投票。通过源投票，验证者将之前不回滚检查点的软承诺升级为永远不回滚的硬（无条件）承诺。

诚实验证者的源投票始终是其链视图中最高的已确认检查点。其目标投票将是当前 Epoch 的检查点，该检查点是源检查点的后代。源和目标检查点不必连续，跳过检查点是允许的。但是，当信标链运行平稳时，一个 Epoch 的目标投票将是下一个 Epoch 的源投票。

![](https://fanwb.oss-cn-beijing.aliyuncs.com/img/eth2book.info_capella_part2_consensus_casper_ffg_2.png)
_从已确认检查点到其后代链上检查点的链接是有效的 途中只展示了检查点，中间的区块被省略_

在有效的链接中，源检查点始终是目标检查点的祖先。否则，验证者会自相矛盾：源投票承诺了永远不会回滚检查点 $s$， 如果目标检查点 $t$ 不是 $s$ 的后代，那么实际上就是在投票回滚 $s$。但发布这样的无效链接并不算可罚没的违规行为。

![](https://fanwb.oss-cn-beijing.aliyuncs.com/img/eth2book.info_capella_part2_consensus_casper_ffg_3.png)
_从已确认检查点到非其后代链上的检查点的链接是无效的 这两个检查点是冲突的，因为它们都不是彼此的祖先_

评估 Casper FFG 投票时，只会考虑在区块中接收到的投票。与 LMD GHOST 的分叉选择不同，验证者不会考虑通过 Gossip 或任何其他方式接收到的 Casper FFG 投票。因为我们围绕最终性的决策必须有一个共同记录，而区块历史正是这样的共同记录。因此，前文提到“告诉网络”时，实际上是说验证者广播了一个见证，该见证将被区块提议者拾取并包含在了一个区块中。当提到“从网络获取”时，实际上是说验证者处理了包含在区块中的见证。

### 绝对多数链接

如上所述，链接是一个 Casper FFG 投票对，用于链接源检查点和目标检查点，$s→t$。

当超过 $\frac{2}{3}$ 的验证者（按权益加权）发布了相同的链接（且其投票被及时包含在区块中）时，链接 $s→t$ 就是一个**绝对多数链接** (Supermajority Link)。

## Casper FFG 运作机制

在了解了大部分术语和关键概念之后，本节将详细介绍 Casper FFG 的运行方式。

### 确认

当节点看到从已确认检查点 $c_1$ 到检查点 $c_2$ 的绝对多数链接时，就会认为检查点 $c_2$ 是已确认的。

![](https://fanwb.oss-cn-beijing.aliyuncs.com/img/eth2book.info_capella_part2_consensus_casper_ffg_5.png)
*节点已经看到绝对多数链接 $C_N→C_{N+2}$ ，因此将 $C_{N+2}$ 标记为已确认 已确认的检查点用阴影线标记并标有“J”*

确认意味着我已经看到超过 $\frac{2}{3}$ 的验证者集做出承诺不会回滚检查点 $c_2$，其条件是收到至少 $\frac{2}{3}$ 同样不回滚 $c_2$ 的验证者的承诺。换句话说，如果一个验证者看到超过 $\frac{2}{3}$ 的其他验证者承诺不回滚检查点$c_2$，那么该验证者本身也承诺不会回滚 $c_2$。

### 最终化

当节点看到从已确认检查点 $c_1$ 到检查点 $c_2$ 的绝对多数链接，且检查点 $c_2$ 是 $c_1$ 的直接子检查点时，就会认为检查点 $c_1$ 是最终化的。

换句话说，当一个已确认检查点的直接子级也已确认时，该检查点成为最终化的检查点。

![](https://fanwb.oss-cn-beijing.aliyuncs.com/img/eth2book.info_capella_part2_consensus_casper_ffg_4.png)
*节点已经看到绝对多数链接 $C_N → C_{N+1}$，因此将 $C_{N+1}$ 标记为已确认 由于 $C_{N+1}$ 是检查点树中 $C_N$ 的直接子级，因而将 $C_N$ 标记为最终化 最终化的检查点用交叉阴影线标记并标有“F”*

最终化意味着我已经看到超过 $\frac{2}{3}$ 的验证者的确定不会回滚检查点 $c_1$，因为其已收到超过 $\frac{2}{3}$ 的验证者的承诺。此时检查点 $c_1$ 已经不可能被回滚，除非至少有  $\frac{1}{3}$  的验证者被证明反悔，并因此受到罚没。

### Casper 守则

在 Casper FFG 论文中，为检查点定义了高度：如果 $c$ 是一个检查点，那么 $h(c)$ 就是该检查点的高度。检查点高度随距创世块的距离单调增加。

在 Eth2 的 Casper FFG 实现中，检查点高度是检查点的 Epoch 编号：$h(c) = c.epoch$。前文提到，检查点包含区块哈希和 Epoch 编号这两个部分。如果这两部分中有任何一个不同，那么检查点就是不同的。

Casper FFG 的可问责安全证明依赖于任何违反以下两条规定（或“惩罚守则”）的验证者都会受到罚没。

#### 禁止重复投票

**守则 1**：验证者不得发布不同的投票 $s_1 → t_1$ 和 $s_2 → t_2$，使得 $h(t_1) = h(t_2)$。

简单来说，验证者对任意目标 Epoch 只能进行最多一次投票。

![](https://fanwb.oss-cn-beijing.aliyuncs.com/img/eth2book.info_capella_part2_consensus_casper_ffg_6.png)
*违反守则 1 的一种方式：使用不同的源检查点投票给相同的目标检查点：$0 → 3$ 和 $1 → 3$*

![](https://fanwb.oss-cn-beijing.aliyuncs.com/img/1715261345638.png)
*违反守则 1 的另一种方式：在同一个 Epoch 中投票给不同的目标检查点：$0 → 3$ 和 $0 → 3'$*

#### 禁止包围投票

**守则 2**：验证者不得发布不同的投票 $s_1 → t_1$ 和 $s_2 → t_2$，使得使得 $h(s_1) < h(s_2) < h(t_2) < h(t_1)$。

也就是说，验证者不得发布投票，使其链接包围或被其先前投票的链接包围。

![](https://fanwb.oss-cn-beijing.aliyuncs.com/img/eth2book.info_capella_part2_consensus_casper_ffg_8.png)
*违反守则 2 的一种方式：链接 $0 → 3$ 包围链接 $1 → 2$*

![](https://fanwb.oss-cn-beijing.aliyuncs.com/img/1715261519685.png)
*违反守则 2 的另一种方式：仍是链接 $0 → 3$ 包围链接 $1 → 2$，但处于不同分支*



